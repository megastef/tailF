// Generated by CoffeeScript 1.10.0
(function() {
  var SeriesQueue, Tail, assert, async, environment, events, fs, iconv, jschardet, split, us,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  events = require("events");

  fs = require('fs');

  async = require('uclogs-async');

  jschardet = require('jschardet');

  iconv = require('iconv-lite');

  assert = require('assert');

  us = require('underscore');

  environment = process.env['NODE_ENV'] || 'development';

  split = function(size, chunk_size) {
    var result;
    result = [];
    while (size > 0) {
      if (size >= chunk_size) {
        result.push(chunk_size);
        size -= chunk_size;
      } else {
        result.push(size);
        size = 0;
      }
    }
    return result;
  };

  SeriesQueue = (function() {
    SeriesQueue.prototype.next = function() {
      var element;
      if (this.queue.length >= 1 && !this.lock) {
        element = this.queue.shift();
        this.lock = true;
        return this.task(element, (function(_this) {
          return function() {
            _this.lock = false;
            if (_this.queue.length >= 1) {
              return setImmediate(function() {
                return _this.next();
              });
            }
          };
        })(this));
      }
    };

    function SeriesQueue(task) {
      this.task = task;
      this.queue = [];
      this.lock = false;
    }

    SeriesQueue.prototype.push = function(element) {
      this.queue.push(element);
      return setImmediate((function(_this) {
        return function() {
          return _this.next();
        };
      })(this));
    };

    SeriesQueue.prototype.clean = function() {
      return this.queue = [];
    };

    SeriesQueue.prototype.length = function() {
      return this.queue.length;
    };

    return SeriesQueue;

  })();

  Tail = (function(superClass) {
    extend(Tail, superClass);

    Tail.prototype._readBlock = function(block, callback) {
      return fs.fstat(block.fd, (function(_this) {
        return function(err, stat) {
          var end, size, split_size, start;
          if (err) {
            return callback();
          }
          start = _this.bookmarks[block.fd];
          end = stat.size;
          if (start > end) {
            start = 0;
          }
          size = end - start;
          if (_this.maxSize > 0 && size > _this.maxSize) {
            start = end - _this.maxSize;
            size = _this.maxSize;
          }
          if (start < 0) {
            start = 0;
          }
          split_size = _this.bufferSize > 0 ? _this.bufferSize : size;
          return async.reduce(split(size, split_size), start, function(start, size, callback) {
            var buff;
            buff = new Buffer(size);
            return fs.read(block.fd, buff, 0, size, start, function(err, bytesRead, buff) {
              var chunk, data, detected_enc, encoding, i, len, parts;
              if (err) {
                _this.emit('error', err);
                return callback(err);
              }
              if (_this.encoding !== 'auto') {
                encoding = _this.encoding;
              } else {
                detected_enc = jschardet.detect(buff);
                if (!(detected_enc != null ? detected_enc.encoding : void 0) || detected_enc.confidence < 0.98) {
                  encoding = "utf-8";
                } else if (!iconv.encodingExists(detected_enc.encoding)) {
                  console.error("auto detected " + detected_enc.encoding + " is not supported, use UTF-8 as alternative");
                  encoding = 'utf-8';
                } else {
                  encoding = detected_enc.encoding;
                }
              }
              data = iconv.decode(buff, encoding);
              _this.buffer += data;
              parts = _this.buffer.split(_this.separator);
              _this.buffer = parts.pop();
              for (i = 0, len = parts.length; i < len; i++) {
                chunk = parts[i];
                _this.emit("line", chunk);
              }
              if (_this.buffer.length > _this.maxLineSize) {
                _this.buffer = '';
              }
              _this.bookmarks[block.fd] = start + bytesRead;
              return callback(null, _this.bookmarks[block.fd]);
            });
          }, function(err) {
            if (err) {
              console.log(err);
              if (err) {
                return callback(err);
              }
            } else {
              return callback();
            }
          });
        };
      })(this));
    };

    Tail.prototype._checkOpen = function(start, inode) {

      /*
        try to open file
        start: the postion to read file start from. default is file's tail position
        inode: if this parameters present, the start take effect if only file has same inode
       */
      var e, error, fd, stat;
      try {
        stat = fs.statSync(this.filename);
        if (!stat.isFile()) {
          throw new Error(this.filename + " is not a regular file");
        }
        fd = fs.openSync(this.filename, 'r');
        if (process.env.DEBUG === 'tail-forever') {
          console.log("\t\t## FD open = " + fd);
        }
        stat = fs.fstatSync(fd);
        this.current = {
          fd: fd,
          inode: stat.ino
        };
        if ((start != null) && start >= 0 && (!inode || inode === stat.ino)) {
          this.bookmarks[fd] = start;
        } else {
          this.bookmarks[fd] = stat.size;
        }
        return this.queue.push({
          type: 'read',
          fd: this.current.fd
        });
      } catch (error) {
        e = error;
        if (e.code === 'ENOENT') {
          return this.current = {
            fd: null,
            inode: 0
          };
        } else {
          throw new Error("failed to read file " + this.filename + ": " + e.message);
        }
      }
    };


    /*
    options:
      - separator: default is '\n'
      - start: where start from, default is the tail of file
      - inode: the tail file's inode, if file's inode not equal this will treat a new file
      - interval: the interval millseconds to polling file state. default is 1 seconds
      - maxSize: the maximum byte size to read one time. 0 or nagative is unlimit.
      - maxLineSize: the maximum byte of one line
      - bufferSize: the memory buffer size. default is 1M. Tail read file content into buffer first. nagative value is no buffer
      - encoding: the file encoding. defalut value is "utf-8",  if "auto" encoding will be auto detected by jschardet
     */

    function Tail(filename, options) {
      var ref, ref1, ref2, ref3, ref4, ref5;
      this.filename = filename;
      this.options = options != null ? options : {};
      this._readBlock = bind(this._readBlock, this);
      if (this.options.start != null) {
        assert.ok(us.isNumber(this.options.start), "start should be number");
      }
      if (this.options.inode != null) {
        assert.ok(us.isNumber(this.options.inode), "inode should be number");
      }
      if (this.options.interval != null) {
        assert.ok(us.isNumber(this.options.interval), "interval should be number");
      }
      if (this.options.maxSize != null) {
        assert.ok(us.isNumber(this.options.maxSize), "maxSize should be number");
      }
      if (this.options.maxLineSize != null) {
        assert.ok(us.isNumber(this.options.maxLineSize), "start maxLineSize should be number");
      }
      if (this.options.bufferSize != null) {
        assert.ok(us.isNumber(this.options.bufferSize), "bufferSize should be number");
      }
      this.separator = (((ref = this.options) != null ? ref.separator : void 0) != null) || '\n';
      this.buffer = '';
      this.queue = new SeriesQueue(this._readBlock);
      this.isWatching = false;
      this.bookmarks = {};
      this._checkOpen(this.options.start, this.options.inode);
      this.interval = (ref1 = this.options.interval) != null ? ref1 : 1000;
      this.maxSize = (ref2 = this.options.maxSize) != null ? ref2 : -1;
      this.maxLineSize = (ref3 = this.options.maxLineSize) != null ? ref3 : 1024 * 1024;
      this.bufferSize = (ref4 = this.options.bufferSize) != null ? ref4 : 1024 * 1024;
      this.encoding = (ref5 = this.options.encoding) != null ? ref5 : 'utf-8';
      if (this.encoding !== 'auto' && !iconv.encodingExists(this.encoding)) {
        throw new Error(this.encoding + " is not supported, check encoding supported list in https://github.com/ashtuchkin/iconv-lite/wiki/Supported-Encodings");
      }
      this.watch();
    }

    Tail.prototype.watch = function() {
      if (this.isWatching) {
        return;
      }
      this.isWatching = true;
      return fs.watchFile(this.filename, {
        interval: this.interval
      }, (function(_this) {
        return function(curr, prev) {
          return _this._watchFileEvent(curr, prev);
        };
      })(this));
    };

    Tail.prototype._watchFileEvent = function(curr, prev) {
      var err, error, oldFd;
      if (curr.ino !== this.current.inode) {
        if (this.current && this.current.fd) {
          if (process.env.DEBUG === 'tail-forever') {
            console.log("\t\tinode changed: @current.fd=" + this.current.fd + " -> closing FD " + this.current.fd);
          }
          oldFd = this.current.fd;
          try {
            fs.closeSync(oldFd);
            if (process.env.DEBUG === 'tail-forever') {
              return console.log("\t\tfile closed " + oldFd);
            }
          } catch (error) {
            err = error;
            return console.log(err);
          } finally {
            delete this.bookmarks[oldFd];
            this._checkOpen(0);
          }
        }
      } else if (this.current.fd) {
        return this.queue.push({
          type: 'read',
          fd: this.current.fd
        });
      }
    };

    Tail.prototype.where = function() {
      if (!this.current.fd) {
        return null;
      }
      return {
        inode: this.current.inode,
        pos: this.bookmarks[this.current.fd]
      };
    };

    Tail.prototype.unwatch = function() {
      var fd, memory, pos, ref;
      this.queue.clean();
      fs.unwatchFile(this.filename);
      this.isWatching = false;
      if (this.current.fd) {
        memory = {
          inode: this.current.inode,
          pos: this.bookmarks[this.current.fd]
        };
      } else {
        memory = {
          inode: 0,
          pos: 0
        };
      }
      ref = this.bookmarks;
      for (fd in ref) {
        pos = ref[fd];
        fs.closeSync(parseInt(fd));
      }
      this.bookmarks = {};
      this.current = {
        fd: null,
        inode: 0
      };
      return memory;
    };

    return Tail;

  })(events.EventEmitter);

  module.exports = Tail;

}).call(this);
